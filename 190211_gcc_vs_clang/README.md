# 背景
- x86 機械語ターゲットプログラム -> C 言語 (`GeneratedCode.c`) -> x86 (x64) 機械語ホストプログラム のように、コード変換をして、任意の x86 機械語プログラムを安全に実行する仕組みを構築しようとしている。
- ここで、ターゲットプログラムがホストプログラムに害を及ぼさないように、ターゲットプログラム用の仮想メモリ空間のアドレス範囲チェックが必要となる。
- アドレス範囲チェックは整数の大小比較 2 回で実現できる。したがって、機械語ターゲットプログラムがメモリアドレスを参照してデータを読み書きしようとする部分に、`GeneratedCode.c` に記載されているように、以下のようなコードを挿入することでチェックできる。
    - 実はこのコードは脆弱で、本来は末尾チェックは vaddr + 4 バイトを比較対象としなければならないが、現在は簡単のために以下のようにしている。
```
#if !NO_CHECK
		if ((vaddr < cont_start || vaddr >= cont_end)) {
			sprintf(exception_string, "Access violation to 0x%x.", vaddr);
			exception_address = 0x80489f8;
			goto L_RETURN;
		}
#endif // !NO_CHECK
```
- 将来的に、ホストプログラムは、gcc または clang の等価物をホストプログラム内に持っている状態とすることを想定している。ホストプログラムは、実行したいターゲット x86 コードについて、逐次、その一部について、`program.c` のような内容を自動生成し、これを gcc または clang  等価物に入力し、出力される機械語コードをメモリ上に展開し、これを実在 CPU で実行するようにしたい。
- すなわち、gcc または clang を、JIT コンパイラとして使用するという考え方である。

# テストプログラムの説明
- `program.c` は、ホストプログラムであり、`main()` 関数が時間測定を行ない、`Iam_The_IntelCPU_HaHaHa()` 関数を呼び出して、10 回の実行にかかった結果時間を 10 で割って表示するものである。
- `GeneratedCode.c` は、x86 機械語ターゲットプログラム -> C 言語 (`GeneratedCode.c`) の実行結果であり、`Iam_The_IntelCPU_HaHaHa()` 関数を実装している。
  - `Iam_The_IntelCPU_HaHaHa()` 関数は、もともとの x86 機械語ターゲットプログラムを C 言語に逆変換した内容である。
  - もともとの x86 機械語ターゲットプログラムの内容は、`target_program_memo.txt` のとおりである。
    - なお、もともとの x86 機械語ターゲットプログラムのソースコード `target_program_memo.txt` は gcc で x86 にコンパイルされており、これの同一 CPU における実行時間は `46` (ms) であった。
  - - 現在の `program.c` の内容は、x86 機械語ターゲットプログラムのうち `test_target2()` という C 言語関数に相当するコードを呼び出し、メモリアクセスを多用する単純なループを 100000000 回繰り返すとともに、整数足し算演算を実行し、その結果を eax レジスタに入れて返却するものである。


# 謎の現象

- `program.c` を gcc でビルドして実行すると、実験 A-1, 実験 B-1 のとおり、ターゲットに対するアドレス境界チェックを無効にした場合と比較して、有効にした場合も、ほとんど速度低下はない。
- ところが、`program.c` を clang でビルドして実行すると、実験 A-1, 実験 B-1 のとおり、ターゲットに対するアドレス境界チェックを無効にした場合と比較して、有効にした場合、**+31% 速度が低下** する。
- この現象の原因を調べるため、gcc と clang とで生成されるアセンブラコードを目視比較したが、clang のほうが最適化を頑張ろうとしてコードの順序を入れ換えるなどしているように見える (大変複雑なので詳細まで解読していない)。この最適化の副作用が原因で速度低下が発生しているのであると推測できる。


# 上記の謎の現象を解決をしたい理由

- 上記の速度低下現象を回避するためには、ホスト内蔵型 JIT 用コンパイラとして、gcc を使えばよいということになる。
- しかし gcc は GPLv3 ライセンスであり制約が大きいため (gcc を内蔵したホストプログラムは GPLv3 ライセンスを適用する必要が生じる)、ライセンス制約の小さい clang (LLVM) をホスト内蔵したい。

# 現在探している解決方法
- clang のクセがよくわからないが、おそらく何らかの最適化手法の副作用が原因で、`GeneratedCode.c` のようなヘンなコードの実行効率が低下しているものと思われる。
- したがってこの副作用を取り除き、**実験 A-2 と実験 B-2 との間の速度低下率が、実験 A-1 と実験 B-1 との間の速度低下率と同等程度になるような、clang を実行する際のオプションフラグ、または、`program.c` のようなコードに付加することができるコンパイル時のフラグなどの魔法のフラグ** を発見することができれば問題は解決する。


# 実験
## 準備
$ git clone https://github.com/dnobori/DNT-CodeSnipet.git
$ cd DNT-CodeSnipet/190211_gcc_vs_clang/
## 実験 A. NO_CHECK マクロを ON (すなわち境界チェックを OFF)
### 結果 A-1. gcc の場合
```
$ gcc -m64 -O2 -DNO_CHECK=1 program.c -o program_by_gcc && ./program_by_gcc

ret = 1165752192
time = 59 (ms)
```

### 結果 A-2. clang の場合
```
$ clang -m64 -O2 -DNO_CHECK=1 program.c -o program_by_clang && ./program_by_clang

ret = 1165752192
time = 67 (ms)
```


## 実験 B. NO_CHECK マクロを OFF (すなわち境界チェックを ON)
### 結果 B-1. gcc の場合
```
$ gcc -m64 -O2 -DNO_CHECK=0 program.c -o program_by_gcc && ./program_by_gcc

ret = 1165752192
time = 60 (ms)
```

### 結果 B-2. clang の場合
```
$ clang -m64 -O2 -DNO_CHECK=0 program.c -o program_by_clang && ./program_by_clang

ret = 1165752192
time = 88 (ms)
```

## 実験結果
gcc では `NO_CHECK=1` とした場合でもほとんど速度低下がみられないが、clang では 31% もの速度低下がみられる。


## 実験環境メモ
```
CPU: Core i7-6700 3.40GHz
gcc: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609
clang: version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)
```


